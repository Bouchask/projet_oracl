-- 1. Tables Creation
CREATE TABLE student (
    student_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    email VARCHAR2(255) UNIQUE NOT NULL,
    academic_level VARCHAR2(255) NOT NULL,
    enrollment_date DATE NOT NULL
);

CREATE TABLE departement (
    departement_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(40) UNIQUE NOT NULL
);

CREATE TABLE course (
    course_code NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title VARCHAR2(255) UNIQUE NOT NULL,
    credits NUMBER NOT NULL CHECK (credits > 0),
    departement_id NUMBER NOT NULL,
    FOREIGN KEY (departement_id) REFERENCES departement(departement_id)
);

CREATE TABLE semester (
    semester_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) NOT NULL,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL
);

CREATE TABLE instructor (
    instructor_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) NOT NULL,
    email VARCHAR2(255) UNIQUE NOT NULL,
    departement_id NUMBER NOT NULL,
    FOREIGN KEY (departement_id) REFERENCES departement(departement_id)
);

CREATE TABLE prerequisite (
    course_code NUMBER NOT NULL,
    prereq_code NUMBER NOT NULL,
    min_grade VARCHAR2(20) NOT NULL,
    PRIMARY KEY (course_code, prereq_code),
    FOREIGN KEY (course_code) REFERENCES course(course_code),
    FOREIGN KEY (prereq_code) REFERENCES course(course_code)
);

CREATE TABLE course_result (
    result_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    course_code NUMBER NOT NULL,
    grade VARCHAR2(255) NOT NULL,
    status VARCHAR2(10) NOT NULL CHECK (status IN ('PASS', 'NV')),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (course_code) REFERENCES course(course_code)
);

-- Note: Oracle uses DATE for time as well. Use TO_DATE function when inserting.
CREATE TABLE section (
    section_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_code NUMBER NOT NULL,
    semester_id NUMBER NOT NULL,
    instructor_id NUMBER NOT NULL,
    max_capacity NUMBER NOT NULL,
    current_enrolled NUMBER NOT NULL,
    day_of_week VARCHAR2(30) NOT NULL,
    start_time DATE NOT NULL, 
    end_time DATE NOT NULL,
    room_location VARCHAR2(40) NOT NULL,
    FOREIGN KEY (course_code) REFERENCES course(course_code),
    FOREIGN KEY (semester_id) REFERENCES semester(semester_id),
    FOREIGN KEY (instructor_id) REFERENCES instructor(instructor_id)
);

CREATE TABLE registration (
    registration_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    section_id NUMBER NOT NULL,
    registration_date DATE NOT NULL,
    status VARCHAR2(30) NOT NULL,
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (section_id) REFERENCES section(section_id)
);

-- 2. Triggers (Corrected)
-- Note: Assuming you have 'grading_scale' table created somewhere else, 
-- otherwise this first trigger will fail.

CREATE OR REPLACE TRIGGER trg_check_capacity
BEFORE INSERT ON registration
FOR EACH ROW
DECLARE
    v_current NUMBER;
    v_max NUMBER;
BEGIN
    SELECT current_enrolled, max_capacity
    INTO v_current, v_max
    FROM section
    WHERE section_id = :NEW.section_id;

    IF v_current >= v_max THEN
        RAISE_APPLICATION_ERROR(-20002, 'Section is full');
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_no_duplicate_course
BEFORE INSERT ON registration
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*)
    INTO v_count
    FROM registration r
    JOIN section s1 ON r.section_id = s1.section_id
    JOIN section s2 ON s2.section_id = :NEW.section_id
    WHERE r.student_id = :NEW.student_id
      AND s1.course_code = s2.course_code
      AND s1.semester_id = s2.semester_id;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20003, 'Student already registered in this course');
    END IF;
END;
/

CREATE OR REPLACE TRIGGER trg_inc_enrolled
AFTER INSERT ON registration
FOR EACH ROW
BEGIN
    UPDATE section
    SET current_enrolled = current_enrolled + 1
    WHERE section_id = :NEW.section_id;
END;
/

CREATE OR REPLACE TRIGGER trg_dec_enrolled
AFTER DELETE ON registration
FOR EACH ROW
BEGIN
    UPDATE section
    SET current_enrolled = current_enrolled - 1
    WHERE section_id = :OLD.section_id;
END;
/

CREATE OR REPLACE TRIGGER trg_check_time
BEFORE INSERT OR UPDATE ON section
FOR EACH ROW
BEGIN
    IF :NEW.start_time >= :NEW.end_time THEN
        RAISE_APPLICATION_ERROR(-20004, 'Invalid time range');
    END IF;
END;
/

-- 3. Views
CREATE OR REPLACE VIEW v_section_capacity AS
SELECT
    s.section_id,
    c.title AS course_title,
    s.max_capacity,
    s.current_enrolled,
    (s.max_capacity - s.current_enrolled) AS available_seats
FROM section s
JOIN course c ON s.course_code = c.course_code;

CREATE OR REPLACE VIEW v_registration_details AS
SELECT
    r.registration_id,
    st.student_id,
    st.first_name,
    st.last_name,
    c.title AS course_title,
    sem.name AS semester,
    r.registration_date,
    r.status
FROM registration r
JOIN student st ON r.student_id = st.student_id
JOIN section s ON r.section_id = s.section_id
JOIN course c ON s.course_code = c.course_code
JOIN semester sem ON s.semester_id = sem.semester_id;

CREATE OR REPLACE VIEW v_students_per_course AS
SELECT
    c.course_code,
    c.title AS course_title,
    COUNT(r.registration_id) AS total_students
FROM course c
JOIN section s ON c.course_code = s.course_code
LEFT JOIN registration r ON s.section_id = r.section_id
GROUP BY c.course_code, c.title;

CREATE OR REPLACE VIEW v_capacity_issues AS
SELECT
    section_id,
    max_capacity,
    current_enrolled
FROM section
WHERE current_enrolled > max_capacity;

CREATE OR REPLACE VIEW v_student_performance AS
SELECT
    st.student_id,
    st.first_name,
    st.last_name,
    c.title AS course_title,
    cr.grade,
    cr.status
FROM course_result cr
JOIN student st ON cr.student_id = st.student_id
JOIN course c ON cr.course_code = c.course_code;