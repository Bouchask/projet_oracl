/* =================================================================================
   SMART UNIVERSITY DB - VERSION FINALE CORRIGEE (COMPOUND TRIGGER)
   ================================================================================= */

-- 1. CLEANUP TOTAL
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE grades_audit CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE student_semester_result CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE course_result CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE registration CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE section CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE prerequisite CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE course CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE student CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE instructor CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE filiere CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE departement CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE semester CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE salle CASCADE CONSTRAINTS';
    EXECUTE IMMEDIATE 'DROP TABLE app_user CASCADE CONSTRAINTS';
    -- Drop Packages
    BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE PKG_SECURITY'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE PKG_ACADEMIC'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE PKG_REGISTRATION'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE PKG_GRADES'; EXCEPTION WHEN OTHERS THEN NULL; END;
    BEGIN EXECUTE IMMEDIATE 'DROP PACKAGE PKG_PREREQ'; EXCEPTION WHEN OTHERS THEN NULL; END;
EXCEPTION WHEN OTHERS THEN NULL;
END;
/

/* =============================================
   2. TABLES
   ============================================= */
CREATE TABLE app_user (
    user_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_apoge VARCHAR2(20) UNIQUE NOT NULL,
    password_hash VARCHAR2(255) NOT NULL,
    role VARCHAR2(20) NOT NULL CHECK (role IN ('ADMIN','STUDENT','TEACHER'))
);

CREATE TABLE departement (
    departement_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(40) UNIQUE NOT NULL
);

CREATE TABLE semester (
    semester_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) UNIQUE NOT NULL, 
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    CHECK (start_date < end_date)
);

CREATE TABLE salle (
    salle_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_salle VARCHAR2(20) UNIQUE NOT NULL,
    capacity NUMBER NOT NULL CHECK (capacity > 0),
    building VARCHAR2(50) NOT NULL
);

CREATE TABLE filiere (
    filiere_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) UNIQUE NOT NULL,
    departement_id NUMBER NOT NULL,
    FOREIGN KEY (departement_id) REFERENCES departement(departement_id)
);

CREATE TABLE instructor (
    instructor_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_apoge VARCHAR2(20) UNIQUE NOT NULL,
    name VARCHAR2(100) NOT NULL,
    email VARCHAR2(255) UNIQUE NOT NULL,
    departement_id NUMBER NOT NULL,
    FOREIGN KEY (code_apoge) REFERENCES app_user(code_apoge),
    FOREIGN KEY (departement_id) REFERENCES departement(departement_id)
);

CREATE TABLE student (
    student_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_apoge VARCHAR2(20) UNIQUE NOT NULL,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    email VARCHAR2(255) UNIQUE NOT NULL,
    academic_level VARCHAR2(20) DEFAULT 'LICENCE', 
    filiere_id NUMBER NOT NULL, 
    current_semester_id NUMBER NOT NULL, 
    enrollment_date DATE DEFAULT SYSDATE,
    FOREIGN KEY (code_apoge) REFERENCES app_user(code_apoge),
    FOREIGN KEY (filiere_id) REFERENCES filiere(filiere_id),
    FOREIGN KEY (current_semester_id) REFERENCES semester(semester_id)
);

CREATE TABLE course (
    course_code NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title VARCHAR2(255) NOT NULL,
    credits NUMBER NOT NULL CHECK (credits > 0),
    total_hours NUMBER DEFAULT 40 NOT NULL,
    filiere_id NUMBER NOT NULL,
    semester_id NUMBER NOT NULL,
    CONSTRAINT uq_course_filiere UNIQUE (title, filiere_id),
    FOREIGN KEY (filiere_id) REFERENCES filiere(filiere_id),
    FOREIGN KEY (semester_id) REFERENCES semester(semester_id)
);

CREATE TABLE prerequisite (
    course_code NUMBER NOT NULL,
    prereq_code NUMBER NOT NULL,
    min_grade CHAR(1) NOT NULL,
    PRIMARY KEY (course_code, prereq_code),
    CHECK (min_grade IN ('A','B','C','D','E','F')),
    FOREIGN KEY (course_code) REFERENCES course(course_code),
    FOREIGN KEY (prereq_code) REFERENCES course(course_code)
);

CREATE TABLE section (
    section_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_code NUMBER NOT NULL,
    instructor_id NUMBER NOT NULL,
    salle_id NUMBER NOT NULL,
    max_capacity NUMBER NOT NULL,
    current_enrolled NUMBER DEFAULT 0,
    day_of_week VARCHAR2(20) NOT NULL,
    start_time DATE NOT NULL,
    end_time DATE NOT NULL,
    FOREIGN KEY (course_code) REFERENCES course(course_code),
    FOREIGN KEY (instructor_id) REFERENCES instructor(instructor_id),
    FOREIGN KEY (salle_id) REFERENCES salle(salle_id)
);

CREATE TABLE registration (
    registration_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    section_id NUMBER NOT NULL,
    status VARCHAR2(20) DEFAULT 'PENDING',
    registration_date DATE DEFAULT SYSDATE,
    CONSTRAINT chk_reg_status CHECK (status IN ('PENDING', 'ACTIVE', 'VALIDE', 'CANCELLED', 'DROPPED')),
    UNIQUE (student_id, section_id),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (section_id) REFERENCES section(section_id)
);

CREATE TABLE course_result (
    result_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    course_code NUMBER NOT NULL,
    grade CHAR(1),
    status VARCHAR2(10),
    CHECK (grade IN ('A','B','C','D','E','F')),
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (course_code) REFERENCES course(course_code)
);

CREATE TABLE student_semester_result (
    ssr_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER NOT NULL,
    semester_id NUMBER NOT NULL,
    status VARCHAR2(20) DEFAULT 'EN_COURS',
    gpa NUMBER(3,2), 
    validation_date DATE DEFAULT SYSDATE,
    FOREIGN KEY (student_id) REFERENCES student(student_id),
    FOREIGN KEY (semester_id) REFERENCES semester(semester_id)
);

CREATE TABLE grades_audit (
    audit_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    student_id NUMBER,
    course_code NUMBER,
    old_grade CHAR(1),
    new_grade CHAR(1),
    change_date DATE DEFAULT SYSDATE,
    user_action VARCHAR2(10)
);

-- INDEXES
CREATE INDEX idx_student_apoge ON student(code_apoge);
CREATE INDEX idx_reg_student ON registration(student_id);
CREATE INDEX idx_section_course ON section(course_code);

/* =============================================
   3. VUES
   ============================================= */
CREATE OR REPLACE VIEW v_course_hours_tracking AS
SELECT 
    c.course_code, c.title AS course_title, f.name AS filiere_name, s.name AS semester_name,
    i.instructor_id, c.total_hours AS budget_heures,
    NVL(SUM((sec.end_time - sec.start_time) * 24), 0) AS heures_planifiees,
    (c.total_hours - NVL(SUM((sec.end_time - sec.start_time) * 24), 0)) AS heures_restantes
FROM course c
JOIN section sec ON c.course_code = sec.course_code
JOIN instructor i ON sec.instructor_id = i.instructor_id
JOIN filiere f ON c.filiere_id = f.filiere_id
JOIN semester s ON c.semester_id = s.semester_id
GROUP BY c.course_code, c.title, f.name, s.name, i.instructor_id, c.total_hours;

CREATE OR REPLACE VIEW v_section_details AS
SELECT s.section_id, c.title AS course_title, sem.name AS semester_name, f.name AS filiere_name, i.name AS instructor_name,
       sa.code_salle, s.day_of_week, s.start_time, s.end_time, s.current_enrolled, s.max_capacity
FROM section s JOIN course c ON s.course_code = c.course_code JOIN filiere f ON c.filiere_id = f.filiere_id
JOIN semester sem ON c.semester_id = sem.semester_id JOIN instructor i ON s.instructor_id = i.instructor_id JOIN salle sa ON s.salle_id = sa.salle_id;

CREATE OR REPLACE VIEW v_section_student_list AS
SELECT sec.section_id, st.code_apoge, st.first_name, st.last_name, st.email, r.status AS registration_status, r.registration_id
FROM section sec JOIN registration r ON sec.section_id = r.section_id JOIN student st ON r.student_id = st.student_id;

CREATE OR REPLACE VIEW v_registration_details AS
SELECT r.registration_id, r.student_id, st.first_name, st.last_name, st.code_apoge, c.title AS course_title, f.name AS filiere_name, r.status, r.registration_date, sec.section_id
FROM registration r JOIN student st ON r.student_id = st.student_id JOIN section sec ON r.section_id = sec.section_id JOIN course c ON sec.course_code = c.course_code JOIN filiere f ON c.filiere_id = f.filiere_id;

CREATE OR REPLACE VIEW v_student_eligible_sections AS
SELECT st.student_id, st.code_apoge, sec.section_id, c.title AS course_title, c.credits, i.name AS instructor_name, sl.code_salle,
       sec.day_of_week, sec.start_time, sec.end_time, sec.current_enrolled, sec.max_capacity, (sec.max_capacity - sec.current_enrolled) AS available_seats
FROM section sec JOIN course c ON sec.course_code = c.course_code JOIN instructor i ON sec.instructor_id = i.instructor_id JOIN salle sl ON sec.salle_id = sl.salle_id
JOIN student st ON st.filiere_id = c.filiere_id AND st.current_semester_id = c.semester_id
WHERE (sec.max_capacity - sec.current_enrolled) > 0
AND NOT EXISTS (SELECT 1 FROM registration r WHERE r.student_id = st.student_id AND r.section_id = sec.section_id);

CREATE OR REPLACE VIEW v_student_transcript AS
SELECT s.code_apoge, s.first_name || ' ' || s.last_name AS full_name, c.title AS course_title, c.credits, cr.grade, cr.status
FROM student s JOIN course_result cr ON s.student_id = cr.student_id JOIN course c ON cr.course_code = c.course_code;

CREATE OR REPLACE VIEW v_section_capacity AS
SELECT s.section_id, c.title, sa.code_salle, s.max_capacity, s.current_enrolled, (s.max_capacity - s.current_enrolled) AS available_seats
FROM section s JOIN course c ON s.course_code = c.course_code JOIN salle sa ON s.salle_id = sa.salle_id;

/* =============================================
   4. PACKAGES PL/SQL
   ============================================= */

-- A. PACKAGE SECURITY
CREATE OR REPLACE PACKAGE PKG_SECURITY AS
    PROCEDURE update_password(p_code_apoge IN VARCHAR2, p_new_pass IN VARCHAR2);
    PROCEDURE update_student_email(p_code_apoge IN VARCHAR2, p_new_email IN VARCHAR2);
    PROCEDURE update_teacher_email(p_code_apoge IN VARCHAR2, p_new_email IN VARCHAR2);
END PKG_SECURITY;
/
CREATE OR REPLACE PACKAGE BODY PKG_SECURITY AS
    PROCEDURE update_password(p_code_apoge IN VARCHAR2, p_new_pass IN VARCHAR2) IS
    BEGIN
        UPDATE app_user SET password_hash = p_new_pass WHERE code_apoge = p_code_apoge;
        IF SQL%ROWCOUNT = 0 THEN RAISE_APPLICATION_ERROR(-20100, 'User introuvable'); END IF;
        COMMIT;
    END;
    PROCEDURE update_student_email(p_code_apoge IN VARCHAR2, p_new_email IN VARCHAR2) IS
    BEGIN UPDATE student SET email = p_new_email WHERE code_apoge = p_code_apoge; COMMIT; END;
    PROCEDURE update_teacher_email(p_code_apoge IN VARCHAR2, p_new_email IN VARCHAR2) IS
    BEGIN UPDATE instructor SET email = p_new_email WHERE code_apoge = p_code_apoge; COMMIT; END;
END PKG_SECURITY;
/

-- B. PACKAGE ACADEMIC
CREATE OR REPLACE PACKAGE PKG_ACADEMIC AS
    FUNCTION get_teacher_dashboard(p_code_apoge IN VARCHAR2) RETURN SYS_REFCURSOR;
    FUNCTION get_section_students(p_section_id IN NUMBER) RETURN SYS_REFCURSOR;
    FUNCTION get_student_id(p_code_apoge IN VARCHAR2) RETURN NUMBER;
END PKG_ACADEMIC;
/
CREATE OR REPLACE PACKAGE BODY PKG_ACADEMIC AS
    FUNCTION get_teacher_dashboard(p_code_apoge IN VARCHAR2) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR
        SELECT course_title, filiere_name, semester_name, budget_heures, heures_planifiees, heures_restantes,
               CASE WHEN heures_planifiees >= budget_heures THEN 'COMPLET' ELSE 'EN_COURS' END AS status
        FROM v_course_hours_tracking v JOIN instructor i ON v.instructor_id = i.instructor_id
        WHERE i.code_apoge = p_code_apoge;
        RETURN v_cursor;
    END;
    FUNCTION get_section_students(p_section_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR SELECT code_apoge, first_name, last_name, email, registration_status, registration_id 
        FROM v_section_student_list WHERE section_id = p_section_id ORDER BY last_name;
        RETURN v_cursor;
    END;
    FUNCTION get_student_id(p_code_apoge IN VARCHAR2) RETURN NUMBER IS
        v_id NUMBER;
    BEGIN SELECT student_id INTO v_id FROM student WHERE code_apoge = p_code_apoge; RETURN v_id;
    EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
END PKG_ACADEMIC;
/

-- C. PACKAGE REGISTRATION
CREATE OR REPLACE PACKAGE PKG_REGISTRATION AS
    PROCEDURE validate_reg(p_reg_id IN NUMBER);
    PROCEDURE cancel_reg(p_reg_id IN NUMBER);
    PROCEDURE drop_reg(p_reg_id IN NUMBER);
END PKG_REGISTRATION;
/
CREATE OR REPLACE PACKAGE BODY PKG_REGISTRATION AS
    PROCEDURE validate_reg(p_reg_id IN NUMBER) IS BEGIN UPDATE registration SET status = 'VALIDE' WHERE registration_id = p_reg_id; COMMIT; END;
    PROCEDURE cancel_reg(p_reg_id IN NUMBER) IS BEGIN UPDATE registration SET status = 'CANCELLED' WHERE registration_id = p_reg_id; COMMIT; END;
    PROCEDURE drop_reg(p_reg_id IN NUMBER) IS BEGIN UPDATE registration SET status = 'DROPPED' WHERE registration_id = p_reg_id; COMMIT; END;
END PKG_REGISTRATION;
/

-- D. PACKAGE GRADES
CREATE OR REPLACE PACKAGE PKG_GRADES AS
    FUNCTION get_student_transcript(p_student_id IN NUMBER) RETURN SYS_REFCURSOR;
    PROCEDURE update_grade(p_result_id IN NUMBER, p_new_grade IN CHAR);
    PROCEDURE delete_result(p_result_id IN NUMBER);
END PKG_GRADES;
/
CREATE OR REPLACE PACKAGE BODY PKG_GRADES AS
    FUNCTION get_student_transcript(p_student_id IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR SELECT cr.result_id, c.title AS course_title, c.credits, cr.grade, cr.status
        FROM course_result cr JOIN course c ON cr.course_code = c.course_code WHERE cr.student_id = p_student_id ORDER BY c.title;
        RETURN v_cursor;
    END;
    PROCEDURE update_grade(p_result_id IN NUMBER, p_new_grade IN CHAR) IS BEGIN UPDATE course_result SET grade = p_new_grade WHERE result_id = p_result_id; COMMIT; END;
    PROCEDURE delete_result(p_result_id IN NUMBER) IS BEGIN DELETE FROM course_result WHERE result_id = p_result_id; COMMIT; END;
END PKG_GRADES;
/

-- E. PACKAGE PREREQ
CREATE OR REPLACE PACKAGE PKG_PREREQ AS
    FUNCTION get_course_prereqs(p_course_code IN NUMBER) RETURN SYS_REFCURSOR;
    PROCEDURE update_prereq(p_course_code IN NUMBER, p_prereq_code IN NUMBER, p_new_min IN CHAR);
    PROCEDURE delete_prereq(p_course_code IN NUMBER, p_prereq_code IN NUMBER);
END PKG_PREREQ;
/
CREATE OR REPLACE PACKAGE BODY PKG_PREREQ AS
    FUNCTION get_course_prereqs(p_course_code IN NUMBER) RETURN SYS_REFCURSOR IS
        v_cursor SYS_REFCURSOR;
    BEGIN
        OPEN v_cursor FOR SELECT p.prereq_code, c.title AS prereq_title, p.min_grade FROM prerequisite p JOIN course c ON p.prereq_code = c.course_code WHERE p.course_code = p_course_code;
        RETURN v_cursor;
    END;
    PROCEDURE update_prereq(p_course_code IN NUMBER, p_prereq_code IN NUMBER, p_new_min IN CHAR) IS BEGIN UPDATE prerequisite SET min_grade = p_new_min WHERE course_code = p_course_code AND prereq_code = p_prereq_code; COMMIT; END;
    PROCEDURE delete_prereq(p_course_code IN NUMBER, p_prereq_code IN NUMBER) IS BEGIN DELETE FROM prerequisite WHERE course_code = p_course_code AND prereq_code = p_prereq_code; COMMIT; END;
END PKG_PREREQ;
/

/* =============================================
   5. TRIGGERS (INTELLIGENCE METIER)
   ============================================= */

-- TRG 1: Section Capacity
CREATE OR REPLACE TRIGGER trg_section_capacity BEFORE INSERT OR UPDATE ON section FOR EACH ROW DECLARE v_room_cap NUMBER; BEGIN
    SELECT capacity INTO v_room_cap FROM salle WHERE salle_id = :NEW.salle_id;
    IF :NEW.max_capacity > v_room_cap THEN RAISE_APPLICATION_ERROR(-20010,'Capacité section > Capacité salle'); END IF;
END;
/

-- TRG 2: Max Hours
CREATE OR REPLACE TRIGGER trg_check_course_hours
BEFORE INSERT OR UPDATE OF course_code, start_time, end_time ON section
FOR EACH ROW
DECLARE
    v_total_hours NUMBER;
    v_new_duration NUMBER;
    v_max_hours NUMBER := 40; -- Max 40h par cours
BEGIN
    -- 1. Calculer durée nouvelle section
    v_new_duration := (TO_DATE(TO_CHAR(:NEW.end_time, 'HH24:MI'), 'HH24:MI') - TO_DATE(TO_CHAR(:NEW.start_time, 'HH24:MI'), 'HH24:MI')) * 24;

    -- 2. Calculer total existant (sans compter celle-ci)
    SELECT NVL(SUM((TO_DATE(TO_CHAR(end_time, 'HH24:MI'), 'HH24:MI') - TO_DATE(TO_CHAR(start_time, 'HH24:MI'), 'HH24:MI')) * 24), 0)
    INTO v_total_hours
    FROM section
    WHERE course_code = :NEW.course_code
      AND section_id != :NEW.section_id;

    -- 3. Vérifier limite
    IF (v_total_hours + v_new_duration) > v_max_hours THEN
        RAISE_APPLICATION_ERROR(-20110, 'Quota horaire cours dépassé (Max 40h).');
    END IF;
END;
/

-- TRG 3: Auto Validate Semester (COMPOUND TRIGGER - ANTI MUTATION)
CREATE OR REPLACE TRIGGER trg_auto_validate_semester
FOR INSERT OR UPDATE ON course_result
COMPOUND TRIGGER
  TYPE t_student_sem IS RECORD (student_id NUMBER, filiere_id NUMBER, semester_id NUMBER);
  TYPE t_student_list IS TABLE OF t_student_sem;
  v_students t_student_list := t_student_list();

  AFTER EACH ROW IS
    v_fil NUMBER; v_sem NUMBER;
  BEGIN
    SELECT filiere_id, current_semester_id INTO v_fil, v_sem FROM student WHERE student_id = :NEW.student_id;
    v_students.EXTEND; v_students(v_students.LAST).student_id := :NEW.student_id; v_students(v_students.LAST).filiere_id := v_fil; v_students(v_students.LAST).semester_id := v_sem;
  END AFTER EACH ROW;

  AFTER STATEMENT IS
    v_total NUMBER; v_passed NUMBER; v_credits NUMBER; v_weighted NUMBER; v_gpa NUMBER;
  BEGIN
    FOR i IN 1 .. v_students.COUNT LOOP
       SELECT COUNT(*) INTO v_total FROM course WHERE filiere_id = v_students(i).filiere_id AND semester_id = v_students(i).semester_id;
       SELECT COUNT(*) INTO v_passed FROM course_result cr JOIN course c ON cr.course_code = c.course_code WHERE cr.student_id = v_students(i).student_id AND c.semester_id = v_students(i).semester_id AND cr.status = 'PASS';
       IF v_passed >= v_total AND v_total > 0 THEN
           SELECT SUM(c.credits), SUM(CASE cr.grade WHEN 'A' THEN 4*c.credits WHEN 'B' THEN 3*c.credits WHEN 'C' THEN 2*c.credits WHEN 'D' THEN 1*c.credits ELSE 0 END)
           INTO v_credits, v_weighted FROM course_result cr JOIN course c ON cr.course_code = c.course_code WHERE cr.student_id = v_students(i).student_id AND c.semester_id = v_students(i).semester_id;
           IF v_credits > 0 THEN
               v_gpa := v_weighted / v_credits;
               MERGE INTO student_semester_result dest USING (SELECT v_students(i).student_id AS sid, v_students(i).semester_id AS semid FROM dual) src
               ON (dest.student_id = src.sid AND dest.semester_id = src.semid)
               WHEN MATCHED THEN UPDATE SET status = 'VALIDE', gpa = v_gpa, validation_date = SYSDATE
               WHEN NOT MATCHED THEN INSERT (student_id, semester_id, status, gpa) VALUES (src.sid, src.semid, 'VALIDE', v_gpa);
           END IF;
       END IF;
    END LOOP;
  END AFTER STATEMENT;
END trg_auto_validate_semester;
/

-- TRG 4: Auto Pending & Count
CREATE OR REPLACE TRIGGER trg_manage_enrollment BEFORE INSERT OR DELETE ON registration FOR EACH ROW DECLARE v_curr NUMBER; v_max NUMBER; BEGIN
    IF INSERTING THEN
        SELECT current_enrolled, max_capacity INTO v_curr, v_max FROM section WHERE section_id = :NEW.section_id;
        IF v_curr >= v_max THEN RAISE_APPLICATION_ERROR(-20020,'Section complète.'); END IF;
        :NEW.status := 'PENDING';
        UPDATE section SET current_enrolled = current_enrolled + 1 WHERE section_id = :NEW.section_id;
    ELSIF DELETING THEN
        UPDATE section SET current_enrolled = current_enrolled - 1 WHERE section_id = :OLD.section_id;
    END IF;
END;
/
-- TRG 8: Check Professor Availability (Anti-Cloning)
CREATE OR REPLACE TRIGGER trg_check_prof_conflict
BEFORE INSERT OR UPDATE OF instructor_id, day_of_week, start_time, end_time ON section
FOR EACH ROW
DECLARE
    v_conflict_count NUMBER;
BEGIN
    -- Ce code ne s'exécutera PLUS si on modifie juste la Capacité ou la Salle !
    SELECT COUNT(*) INTO v_conflict_count
    FROM section
    WHERE instructor_id = :NEW.instructor_id
      AND day_of_week = :NEW.day_of_week
      AND section_id != :NEW.section_id
      AND (TO_CHAR(:NEW.start_time, 'HH24:MI') < TO_CHAR(end_time, 'HH24:MI'))
      AND (TO_CHAR(start_time, 'HH24:MI') < TO_CHAR(:NEW.end_time, 'HH24:MI'));

    IF v_conflict_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20120, 'Conflit: Ce professeur a déjà un cours sur ce créneau.');
    END IF;
END;
/
CREATE OR REPLACE FUNCTION get_student_transcript(p_student_id IN NUMBER) 
RETURN SYS_REFCURSOR 
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT 
            c.title AS cours,
            sem.name AS semestre,
            i.name AS prof,
            cr.grade AS note, -- La note vient de COURSE_RESULT (cr), pas de REGISTRATION (r)
            r.status AS statut
        FROM registration r
        JOIN section s ON r.section_id = s.section_id
        JOIN course c ON s.course_code = c.course_code
        JOIN instructor i ON s.instructor_id = i.instructor_id
        JOIN semester sem ON c.semester_id = sem.semester_id
        -- AJOUT DE LA JOINTURE POUR LA NOTE
        LEFT JOIN course_result cr ON r.student_id = cr.student_id AND c.course_code = cr.course_code
        WHERE r.student_id = p_student_id
        ORDER BY sem.start_date DESC, c.title ASC;
        
    RETURN v_cursor;
END;
/
CREATE OR REPLACE FUNCTION get_teacher_schedule_details(p_instructor_id IN NUMBER) 
RETURN SYS_REFCURSOR 
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT 
            s.section_id,
            c.title AS cours,
            f.name AS filiere,
            sem.name AS semestre,
            sa.code_salle AS salle,
            s.day_of_week AS jour,
            TO_CHAR(s.start_time, 'HH24:MI') AS debut,
            TO_CHAR(s.end_time, 'HH24:MI') AS fin,
            s.current_enrolled || '/' || s.max_capacity AS occupation
        FROM section s
        JOIN course c ON s.course_code = c.course_code
        JOIN filiere f ON c.filiere_id = f.filiere_id
        JOIN semester sem ON c.semester_id = sem.semester_id -- Correction jointure semestre
        JOIN salle sa ON s.salle_id = sa.salle_id
        WHERE s.instructor_id = p_instructor_id
        ORDER BY 
            CASE s.day_of_week 
                WHEN 'Lundi' THEN 1 WHEN 'Mardi' THEN 2 WHEN 'Mercredi' THEN 3 
                WHEN 'Jeudi' THEN 4 WHEN 'Vendredi' THEN 5 WHEN 'Samedi' THEN 6 
            END, s.start_time;
            
    RETURN v_cursor;
END;
/
CREATE OR REPLACE FUNCTION get_course_sections_details(p_course_code IN NUMBER) 
RETURN SYS_REFCURSOR 
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT 
            s.section_id,
            i.name AS prof_name,
            sa.code_salle,
            sa.building,
            s.day_of_week,
            TO_CHAR(s.start_time, 'HH24:MI') AS start_t,
            TO_CHAR(s.end_time, 'HH24:MI') AS end_t,
            -- Calcul de la durée en heures pour cette séance
            (s.end_time - s.start_time) * 24 AS duration_hours,
            s.current_enrolled,
            s.max_capacity
        FROM section s
        JOIN instructor i ON s.instructor_id = i.instructor_id
        JOIN salle sa ON s.salle_id = sa.salle_id
        WHERE s.course_code = p_course_code
        ORDER BY s.start_time ASC;
        
    RETURN v_cursor;
END;
/
CREATE OR REPLACE FUNCTION get_filiere_courses(p_filiere_id IN NUMBER, p_semester_id IN NUMBER) 
RETURN SYS_REFCURSOR 
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT 
            c.course_code,
            c.title,
            c.credits,
            c.total_hours,
            (SELECT COUNT(*) FROM section s WHERE s.course_code = c.course_code) as active_sections
        FROM course c
        WHERE c.filiere_id = p_filiere_id 
          AND c.semester_id = p_semester_id
        ORDER BY c.title ASC;
        
    RETURN v_cursor;
END;
/
CREATE OR REPLACE FUNCTION get_instructor_dept_info(p_instructor_id IN NUMBER) 
RETURN SYS_REFCURSOR 
IS
    v_cursor SYS_REFCURSOR;
BEGIN
    OPEN v_cursor FOR
        SELECT 
            i.instructor_id,
            i.name AS prof_name,
            d.departement_id,
            d.name AS dept_name
        FROM instructor i
        JOIN departement d ON i.departement_id = d.departement_id
        WHERE i.instructor_id = p_instructor_id;
        
    RETURN v_cursor;
END;
/
CREATE OR REPLACE PROCEDURE update_instructor_dept(
    p_instructor_id IN NUMBER, 
    p_new_dept_id IN NUMBER
)
IS
BEGIN
    -- Mise à jour du département
    UPDATE instructor 
    SET departement_id = p_new_dept_id 
    WHERE instructor_id = p_instructor_id;
    
    -- Vérification si le prof existe
    IF SQL%ROWCOUNT = 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'Erreur : Professeur introuvable.');
    END IF;
    
    COMMIT;
END;
/
CREATE OR REPLACE TRIGGER trg_prevent_prof_dept_change
BEFORE UPDATE OF departement_id ON instructor
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    -- On vérifie seulement si le département change vraiment
    IF :OLD.departement_id != :NEW.departement_id THEN
        
        -- On compte les sections actives liées à l'ANCIEN département
        -- Chemin : Section -> Course -> Filiere -> Departement
        SELECT COUNT(*)
        INTO v_count
        FROM section s
        JOIN course c ON s.course_code = c.course_code
        JOIN filiere f ON c.filiere_id = f.filiere_id
        WHERE s.instructor_id = :OLD.instructor_id  -- Le prof concerné
          AND f.departement_id = :OLD.departement_id; -- L'ancien département

        -- Si on trouve des sections, on bloque
        IF v_count > 0 THEN
            RAISE_APPLICATION_ERROR(-20060, 'Impossible de changer le département : Ce professeur a encore des cours actifs liés à son département actuel.');
        END IF;
        
    END IF;
END;
/
COMMIT;